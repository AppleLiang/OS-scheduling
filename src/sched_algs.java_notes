
    /**
     * SJF: Locate the smallest job in a queue 
     */
    Process findShortestJob(Vector que){
	Process p=null,shortest=null;
	long time=0,shorttime=0;
	
	for(int i=0; i < que.size(); ++i){
	    p = (Process) que.get(i);
	    time = p.getBurstTime();
	    if( (time < shorttime) || (i == 0) ){
		shorttime = time;
		shortest = p;
	    }
	}
	return shortest;
    }
    
    /** 
     * find the job with the highest priority
     * In case of tie take first in the queue 
     */
    Process findLoftiestJob(Vector que){
	Process p=null,loftiest=null;
	long priority=0, highest=0;
	
	for(int i=0; i < que.size(); ++i){
	    p = (Process) que.get(i);
	    priority = p.getPriorityWeight();
	    if( ( priority < highest ) || (i == 0) ){
		highest = priority;
		loftiest = p;
	    }
	}
	return loftiest;
    }
		

    /** Do the SJF scheduling algorithm. */
    void RunSJF(Vector jq){
	Process p;
	try {
	    if(  busy == 0 || activeJob.isFinished() || preemptive == true ){
		activeJob = findShortestJob(jq);
		activeIndex = jq.indexOf(activeJob);
	    }
	}
	catch( NullPointerException e){
	}
    }

    /** Do the Priority scheduling algorithm */
    void RunPriority(Vector jq){
	try {
	    if( busy == 0 || activeJob.isFinished() || preemptive == true ){
		activeJob = findLoftiestJob(jq);
		activeIndex = jq.indexOf(activeJob);
	    }
	}
	catch( NullPointerException e){
	}
    }

    /** Do the RR scheduling algorithm */
    void RunRoundRobin(Vector jq){
		/**if( priority == true ){
		    // weight timeslice by priority
		    //quantumCounter = quantum * activeJob.getPriorityWeight(); // backwards
		    quantumCounter = quantum * (10 - activeJob.getPriorityWeight() ); // backwards
		}
		else{
		    quantumCounter = quantum;
		    }*/
		
	    //quantumCounter--;
	
    }

